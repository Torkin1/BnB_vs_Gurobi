from abc import abstractmethod
from copy import deepcopy
from logic.problem import Solver
from treelib import Tree

class BranchAndBound(Solver):
    """ an implementation of the Branch and Bound algorithm for solving Single Machine Scheduling Problem """

    def __init__(self, subSolverClass):

        self.incumbentBound = float("inf")  
        """value of incumbent bound"""
        self.incumbent = None   
        """a pointer to the incumbent solution, in the same format as the one used in given problem to solve"""
        self.subSolverClass = subSolverClass  
        """ a pointer to the solver class which will be instantiated to calculate bounds for generated subproblems """
        self.problemsTree = Tree()
        """keeps track of subproblems generated by the algorithm"""
        self.toExplore = []
        """keeps track of remaining tree nodes to explore"""

    @abstractmethod
    def branch(self, problem):
        pass    
                    
    @abstractmethod
    def isFathomed(self, toFathom):
        """True if problem does not need further decomposition, False otherwise"""
        pass

    def __solve_bnb(self):

        while len(self.toExplore) != 0:
            pNode = self.toExplore.pop()
            if not self.isFathomed(pNode) :
                subProblemNodes = self.branch(pNode)
                for node in subProblemNodes:
                    self.problemsTree.add_node(node, parent=pNode)
                self.toExplore += subProblemNodes
                                        
    def __call__(self, problem):
        """ solves problem using BnB algorithm"""

        self.problemsTree.create_node(data=problem)
        self.toExplore += self.branch(self.problemsTree.get_node(self.problemsTree.root))
        for n in self.toExplore:
            self.problemsTree.add_node(n, parent=self.problemsTree.root)

        self.__solve_bnb()
        
        problem.vars = self.incumbent
